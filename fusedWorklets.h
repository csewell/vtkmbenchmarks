#include <vtkm/Pair.h>
#include <vtkm/Types.h>
#include <vtkm/worklet/DispatcherMapField.h>
#include <vtkm/worklet/WorkletMapField.h>

namespace worklets
{
/// \brief Computes Marching Cubes case number for each cell, along with the number of vertices generated by that case
///
template <typename FieldType, typename CountType, typename VertNumType, int NumCellsToFuse>
class FusedClassifyCell : public vtkm::worklet::WorkletMapField
{
public:
  typedef void ControlSignature(FieldIn<IdType> inputCellId, FieldOut<AllTypes> hasOutput, FieldOut<AllTypes> numCellsOut);
  typedef _3 ExecutionSignature(_1, _2);
  typedef _1 InputDomain;

  typedef typename PortalTypes<FieldType>::PortalConst FieldPortalType;
  FieldPortalType pointData;

  typedef typename PortalTypes<vtkm::Id>::PortalConst TablePortalType;
  TablePortalType vertTable;

  float isovalue;
  int xdim, ydim, zdim;
  int cellsPerLayer;
  int pointsPerLayer;

  template<typename T, typename U>
  VTKM_CONT_EXPORT
  FusedClassifyCell(const T& pointHandle,
               const U& vertTableHandle,
               float iso,
               int dims[3]) :
         pointData( pointHandle.PrepareForInput( DeviceAdapter() ) ),
         vertTable( vertTableHandle.PrepareForInput( DeviceAdapter() ) ),
         isovalue( iso ),
         xdim(dims[0]),
         ydim(dims[1]),
         zdim(dims[2]),
         cellsPerLayer((xdim - 1) * (ydim - 1)),
         pointsPerLayer (xdim*ydim)
   {

   }

  VTKM_EXEC_EXPORT
  VertNumType operator()(vtkm::Id firstCellId, CountType& hasOutput) const
  {
    //compute the first x,y,z before we loop.
    int i0 = 0;
    {
      const vtkm::Id cellId = (firstCellId * NumCellsToFuse);
      const int x = cellId % (xdim - 1);
      const int y = (cellId / (xdim - 1)) % (ydim -1);
      const int z = cellId / cellsPerLayer;
      i0 = x + y*xdim + z * pointsPerLayer;
    }

    // Compute indices for the vertices of this cell
    int i1 = i0   + 1;
    int i2 = i0   + 1 + xdim;
    int i3 = i0   + xdim;
    int i4 = i0   + pointsPerLayer;
    int i5 = i1   + pointsPerLayer;
    int i6 = i2   + pointsPerLayer;
    int i7 = i3   + pointsPerLayer;

    // Get the field values at the vertices
    float f0 = this->pointData.Get(i0);
    float f1 = this->pointData.Get(i1);
    float f2 = this->pointData.Get(i2);
    float f3 = this->pointData.Get(i3);
    float f4 = this->pointData.Get(i4);
    float f5 = this->pointData.Get(i5);
    float f6 = this->pointData.Get(i6);
    float f7 = this->pointData.Get(i7);

    unsigned int cubeindex = (f0 > isovalue);
    cubeindex += (f1 > isovalue)*2;
    cubeindex += (f2 > isovalue)*4;
    cubeindex += (f3 > isovalue)*8;
    cubeindex += (f4 > isovalue)*16;
    cubeindex += (f5 > isovalue)*32;
    cubeindex += (f6 > isovalue)*64;
    cubeindex += (f7 > isovalue)*128;
    VertNumType vertCount = this->vertTable.Get(cubeindex);

    //handle if we are fusing multiple cells now
    for(int i=1; i < NumCellsToFuse; ++i)
      {
      //update the left hand verts to be the old right hand verts
      //shape of voxel back face is:
      // 7 6
      // 4 5
      //shape of voxel front face is:
      // 3 2
      // 0 1

      i0 = i1;
      i3 = i2;
      i4 = i5;
      i7 = i6;

      //update the last 4 verts to be new values
      ++i1;
      ++i2;
      ++i5;
      ++i6;

      f0 = f1;
      f1 = this->pointData.Get(i1);
      f3 = f2;
      f2 = this->pointData.Get(i2);
      f4 = f5;
      f5 = this->pointData.Get(i5);
      f7 = f6;
      f6 = this->pointData.Get(i6);

      // Compute the Marching Cubes case number for this cell
      cubeindex =  (f0 > isovalue);
      cubeindex += (f1 > isovalue)*2;
      cubeindex += (f2 > isovalue)*4;
      cubeindex += (f3 > isovalue)*8;
      cubeindex += (f4 > isovalue)*16;
      cubeindex += (f5 > isovalue)*32;
      cubeindex += (f6 > isovalue)*64;
      cubeindex += (f7 > isovalue)*128;

      //saving number of triangles not number of verts
      vertCount += this->vertTable.Get(cubeindex);
      }

    // Return the number of triangles this case generates
    hasOutput = (vertCount == 0) ? 0 : 1;
    return vertCount;
  }
};

}